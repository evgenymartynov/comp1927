displayFour :: Picture -> Picture -> Picture -> Picture -> Picture
displayFour a b c d =
    Above 1 1
    (Beside 1 1 a b)
    (Beside 1 1 c d)
;

polyline :: [(Num, Num)] -> [Shape]
polyline list = let
    aux :: (Num, Num) -> [(Num, Num)] -> [Shape]
    aux prev list = match list with
        []   -> []
    |   x:xs -> (Line prev x):(aux x xs)
    end;
in match list with
    x:xs -> aux x xs
end;

overlayList :: [Picture] -> Picture
overlayList pics = match pics with
    []   -> Empty
|   x:xs -> Overlay x (overlayList xs)
end;

koch :: Num -> Picture
koch zlevel = let
    aux :: Num -> Num -> Num -> Num -> Num -> Picture
    aux zoom sx sy ex ey = let
        hsqr    :: Num hsqr    = 0.866025404; -- sqrt(3)/2; used in poor-man's trig
        dx :: Num dx = ex-sx;
        dy :: Num dy = ey-sy;

        firstx  :: Num firstx  = (2*sx+ex)/3;
        firsty  :: Num firsty  = (2*sy+ey)/3;
        secondx :: Num secondx = (sx+2*ex)/3;
        secondy :: Num secondy = (sy+2*ey)/3;
        midx :: Num midx = firstx + (dx/3)/2 - (dy/3)*hsqr;
        midy :: Num midy = firsty + (dy/3)/2 + (dx/3)*hsqr;

        finalisePattern :: Num -> Num -> Num -> Num -> Picture
        finalisePattern sx sy ex ey = Canvas 100 100 [Line (sx, sy) (ex, ey)];

        next :: (Num -> Num -> Num -> Num -> Picture)
        next = if (zoom <= 0) then (finalisePattern) else (aux (zoom-1)) end;
    in overlayList
        [ (next sx sy firstx firsty)
        , (next firstx firsty midx midy)
        , (next midx midy secondx secondy)
        , (next secondx secondy ex ey)
        ];
in overlayList
    [ (aux zlevel 15 70 85 70)
    , (aux zlevel 50 9.3782 15 70)
    , (aux zlevel 85 70 50 9.3782)
    ];

drawFractal ::
    (Num -> Num -> Num -> Num -> Num) ->
    (Num -> Num -> Num -> Num -> Num) ->
    Num -> Num -> Num -> Picture
drawFractal xGenerator yGenerator cx cy zoomWidth = let
    maxIter :: Num
    maxIter = 150;

    colscale :: Num
    colscale = 256 / maxIter;

    numIterations :: Num -> Num -> Num
    numIterations px py = let
        auxConverges :: Num -> Num -> Num -> Num
        auxConverges x y iter =
            if (iter == maxIter || ((x*x) + (y*y)) > 4) then
                iter
            else
                auxConverges
                    (xGenerator x y px py)
                    (yGenerator x y px py)
                    (iter+1)
            end;
    in auxConverges px py 0;

    colours :: Num -> (Num, Num, Num)
    colours n =
        ( ((n * colscale) * 1 % 256)
        , ((n * colscale) * 1.5 % 256)
        , ((n * colscale) * 2 % 256)
        );

    polyOrEmpty :: [(Num, Num)] -> Num -> Num -> Picture
    polyOrEmpty points x y =
        if (numIterations x y) < maxIter then
            Canvas 100 100 [
                FilledPolygon (colours (numIterations x y) ) points
            ]
        else
            Empty
        end;

    triangleUp :: Num -> Num -> Num -> Num -> Picture
    triangleUp x1 y1 x2 y2 =
        polyOrEmpty
            [ (0, 0) , (0, 100) , (100, 100) ]
            ((x1+x2+x1)/3)
            ((y1+y2+y2)/3);

    triangleDown :: Num -> Num -> Num -> Num -> Picture
    triangleDown x1 y1 x2 y2 =
        polyOrEmpty
            [ (0, 0) , (100, 0) , (100, 100) ]
            ((x1+x2+x2)/3)
            ((y1+y2+y1)/3);

    auxDraw :: Num -> Num -> Num -> Num -> Num -> Picture
    auxDraw x1 x2 y1 y2 depth =
        if depth == 0 then
            polyOrEmpty [(0, 0), (100, 0), (100, 100), (0, 100)] x1 y2
            --Overlay
            --    (triangleUp   x1 y1 x2 y2)
            --    (triangleDown x1 y1 x2 y2)
        else
            displayFour
                (auxDraw x1 (x1 + (x2-x1)/2)   y1 (y1 + (y2-y1)/2) (depth-1) )
                (auxDraw (x1 + (x2-x1)/2) x2   y1 (y1 + (y2-y1)/2) (depth-1) )
                (auxDraw x1 (x1 + (x2-x1)/2)   (y1 + (y2-y1)/2) y2 (depth-1) )
                (auxDraw (x1 + (x2-x1)/2) x2   (y1 + (y2-y1)/2) y2 (depth-1) )
        end
    ;
in auxDraw (cx-zoomWidth) (cx+zoomWidth) (cy-zoomWidth) (cy+zoomWidth) 6;


julia :: Picture
julia = let
    juliaXStep :: Num -> Num -> Num -> Num -> Num
    juliaXStep x y px py = (x*x - y*y + (0-0.8));
    juliaYStep :: Num -> Num -> Num -> Num -> Num
    juliaYStep x y px py = (2*y*x + (0.156));
in drawFractal juliaXStep juliaYStep 0 0 0.5;

julia2 :: Picture
julia2 = let
    julia2XStep :: Num -> Num -> Num -> Num -> Num
    julia2XStep x y px py = (x*x - y*y + (0-0.4));
    julia2YStep :: Num -> Num -> Num -> Num -> Num
    julia2YStep x y px py = (2*y*x + (0.6));
in drawFractal julia2XStep julia2YStep (0-0.335) 0.35 0.20;

julia3 :: Picture
julia3 = let
    julia3XStep :: Num -> Num -> Num -> Num -> Num
    julia3XStep x y px py = (x*x - y*y + (0.285));
    julia3YStep :: Num -> Num -> Num -> Num -> Num
    julia3YStep x y px py = (2*y*x + (0.01));
in drawFractal julia3XStep julia3YStep (0-0.6) (0-0.3) 0.25;

mandel :: Picture
mandel = let
    mandelXStep :: Num -> Num -> Num -> Num -> Num
    mandelXStep x y px py = (x*x - y*y + px);
    mandelYStep :: Num -> Num -> Num -> Num -> Num
    mandelYStep x y px py = (2*y*x     + py);
in drawFractal mandelXStep mandelYStep (0-0.745) 0.15 0.005;

main = displayFour
    julia (koch 5)
    mandel julia3
